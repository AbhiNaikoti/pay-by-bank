# SDK Implementation Guide
<p>Follow the appropriate steps to complete. Based on the overall architecture diagram, the Merchant server is required to integrate with the below ConnectPay services exposed through First API (Fiserv's API gateway).</p>

## Overview 
<p>
ConnectPayAPI uses full payload encryption (not selective field, or field level encryption)
<br>
This is done with the intent to stop **Man In The Middle (MITM)** attacks.
<br>
Full payload encryption is achieved by encrypting the payload using Symmetric (AES) encryption with dynamically generated encryption key and Asymmetric (RSA) encryption for encrypting the Symmetric Keys.
<br>
**Why are both Symmetric and Asymmetric cryptography is required for full payload encryption?**
<br>
RSA encryption with 2048 bit keys have a limitation on the length of data that it can encrypt.
<br>
The request / response payload for ConnectPay does not fit within that limit.
<br>
Hence, AES encryption is required to encrypt the request/response payloads.
<br>
The AES encryption uses a symmetric keys that should be shared between merchant and ConnectPay.
<br>
Having a static AES key is a bottleneck in the event of key compromise.
<br>
So on each call we expect a random AES key to be generated by the caller and used for encrypting the payload. Subsequently, the Symmetric key should be encrypted using the RSA public key and sent across along with the AES encrypted payload.
</p>

<p>
**How does this encryption model prevent MITM?**<
<br>
All request and response payload are encrypted and looks like gibberish to the person seeing it.
<br>
So even if an eves dropper succeeds to break TLS1.2 encryption in between sender (merchant) and receiver (ConnectPay backend app), all he would see is gibberish.
<br>
He would not be able to identify any fields passed or their values.
<br>
**What is the necessity of this encryption model for Server to Server secure communication?**
<br>
Server to server call is **relatively** secure than coming from an end users phone (which could be hacked).
<br>
In this context Server to Server communication is not via a leased line/dedicated channel, but, over public network/internet.
Server to server authentication is established using HMAC, however, that doesn’t prevent MITM attack.
<br>
Any communication that happens over the public network/ internet is prone to attack and needs to be secured beyond just using TLS1.2 encryption.
<br>
Hence full payload encryption is required for protecting merchant and consumer data.
<br>

>Note: If you need to migrate from old to new encryption standards, please follow this link: [encryption standards migration](https://github.com/Fiserv/connect-pay/blob/develop/documentation/encryptionstandardsmigration.md)

## Headers Information 
### Sample Header
```
"Content-Type" : "application/json"
"Api-Key" : "YMgw8VSrYMG6WTIUnoUUGv7hF9Aqh3EO"
"Timestamp": "1607368688646"
"Authorization" : "HMAC W5X9NAlPgSNsfQX55fXbXrk3arzL6KxcCTA6SrnxL+U="
"Client-Token" : "IXwY1BYpvWpoGzete43AdLzXSdj4"
```

## Security Section

## HMAC Signature Generation High Level Flow

This is needed in the headers to make a successful call.
<br>
<p>The HMAC signature is used in all calls made through our API and is a necessary step to receive a successful response from the system.</p>
1. Get the apikey or the merchant's ConnectPay FirstAPI key
2. Get and save the current UTC timestamp, to the millisecond
3. Concatenate the two paramters to output apikey:timestamp
4. Get the request payload or the actual content passed as a post request
5. Create a hash of the payload using SHA256
6. Encode the hash using Base64 to create base64ofPayloadDigest
7. Concatenate apikey:timestamp with base64ofPayloadDigest to create apikey:timestamp:base64ofPayloadDigest
8. Get the apiSecret or the merchant's ConnectPay FirstAPI secret
9. Create the HMAC value using HMAC SHA256, apikey:timestamp:base64ofPayloadDigest, and the apiSecret as the secret for the HMAC SHA256 calculation
10. Encode the new HMAC value using Base64 to create the signature
11. Append the signature to HMAC followed by a space to create "HMAC Signature"
12. The "Authorization" header = HMAC signature

Below is sample code on how to create the "Authorization" header:
```java
import java.security.MessageDigest;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
public class HmacUtil {
    private static final String CT_CLN = ":";
    private static final String MD_ALG = "SHA-256";
    private static final String HMAC_ALG = "HmacSHA256";
    public static String generateHmac(String apiKey,
    String apiSecret,String epochTimestamp, String payload) throws Exception {
        byte[] hash = MessageDigest.getInstance(MD_ALG).digest(payload.getBytes());
        String encPyld = Base64.encodeBase64String(hash);
        String messageToSign = apiKey + CT_CLN + epochTimestamp + CT_CLN + encPyld;
        Mac hmac = Mac.getInstance(HMAC_ALG);
        SecretKeySpec key = new SecretKeySpec(apiSecret.getBytes(), HMAC_ALG);
        hmac.init(key);
        return Base64.encodeBase64String(hmac.doFinal(messageToSign.getBytes()));
    }
}
```
## ConnectPay API (AES/RSA) Encryption Model (Sequence of activities)

<ol>
    <li> The initial CreateSessionToken call provides an RSA public key </li>
    <li> MAS / App / SDK generate a random AES Key and IV each time </li>
    <li> Merchant uses the AES Key and IV from above step to encrypt the payload using AES encryption. The encrypted payload is called componentDelta </li>
    <li> The random AES Key and random IV generated by MAS / App / SDK are encrypted using the RSA public key from CreateSessionToken call </li>
    <li>AES Key encrypted using RSA public key is called componentX, and IV encrypted using RSA public key is called componentY.  </li>
    <li>componentX, componentY and componentDelta are all transmitted from MAS/ App / SDK to ConnectPayAPI over TLS1.2 </li>
    <li>ConnectPayAPI first decrypts AES Key and IV using RSA decryption with private key</li>
    <li> ConnectPayAPI then decrypts the encrypted payload using AES Key and IV from above step</li>
    <li>ConnectPayAPI completes processing the request </li>
    <li>ConnectPayAPI encrypts the response payload using the AES Key and IV and sends it back in a field called componentDelta  </li>
    <li>MAS / App / SDK receives the encrypted response and decrypts it using AES Key and IV it generated above </li>
    <li>MAS / App / SDK complete processing the response </li>
    <li>MAS / App / SDK should destroy the AES Key and IV generated for this functional call</li>
</ol>

### AES Generator
Most of the ConnectPay APIs need to be encrypted prior to making a request. The methodologies are discussed below with example code on the actual methods in Java. We will use these methods later in order to generate and encrypt the payloads.
<br>
The AES Key generated must be size 256-bit in order for the Fiserv systems to decrypt the request payload.

#### AES Key Generator
The AES Key will be used to encrypt the actual request payload. Below is sample code on how to generate the merchant's AES Key:
```java
private static final char[] HEX_ARRAY = "0123456789abcdef".toCharArray(); 

private String randomHexString(int size) { 
    SecureRandom random = new SecureRandom(); 
    byte[] iv = new byte[count / 8]; 
    random.nextBytes(iv); 
    return bytesToHex(iv); 
} 

public static String bytesToHex(byte[] bytes) { 
    char[] hexChars = new char[bytes.length * 2]; 
    for (int j = 0; j < bytes.length; j++) { 
        int v = bytes[j] & 0xFF; 
        hexChars[j * 2] = HEX_ARRAY[v >>> 4]; 
        hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F]; 
    } 
    return new String(hexChars); 
} 
```
</details>

<details>
<summary>2. IV Generation</summary>
<br>
The IV generated must be size 96-bit in order for the Fiserv systems to decrypt the request payload.

#### Key Generator
The IV will be used to encrypt the actual request payload. Below is sample code on how to generate the merchant's IV:
```java
private static final char[] HEX_ARRAY = "0123456789abcdef".toCharArray(); 

private String randomHexString(int size) { 
    SecureRandom random = new SecureRandom(); 
    byte[] iv = new byte[count / 8]; 
    random.nextBytes(iv); 
    return bytesToHex(iv); 
} 

public static String bytesToHex(byte[] bytes) { 
    char[] hexChars = new char[bytes.length * 2]; 
    for (int j = 0; j < bytes.length; j++) { 
        int v = bytes[j] & 0xFF; 
        hexChars[j * 2] = HEX_ARRAY[v >>> 4]; 
        hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F]; 
    } 
    return new String(hexChars); 
} 
```
</details>

<details>
<summary>3. AES Encryption</summary>
<br>
The merchant must implement methods for AES encryption in order to encrypt the payload prior to making a call.

### AES Encryption/Decryption Specification
| Type | Value            | 
|------|------------------|
|ALGO  |AES               | 
|CIPHER| AES/GCM/NoPadding|

### AES Encryption
AES Encryption will be used to encrypt the actual payload using the AES Key and IV generated before. Below is sample code on how to encrypt using AES:
```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;

    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * encryption with secret key, IV and salt (IV value)
    */
    public String encrypt(String clearText, String correlationId) throws Exception {
        if (this.correlationId == null)
            this.correlationId = correlationId;
        try {
            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, secretKey, initializationVector,
                clearText.getBytes("UTF-8"));
            byte[] IV_BYTES = hex(initializationVector);
            byte[] cipherTextWithIv = ByteBuffer.allocate(IV_BYTES.length + encrypted.length).put(IV_BYTES)
                .put(encrypted).array();
            return base64(cipherTextWithIv);
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```
</details>

<details>
<summary>4. RSA Encryption</summary>
<br>
The merchant must implement RSA Encryption in order to encrypt the AES key and IV using the RSA "publicKey" generated from the "Create Session Token" API.

### RSA Specification
| Type | Value                               | 
|------|-------------------------------------|
|ALGO  |RSA                                  | 
|CIPHER|RSA/None/OAEPwithSHA512AndMGF1Padding|

### RSA Encryption
RSA will be used to encrypt Components X and Y which are the AES Key and IV respectively. These are encrypted using the RSA public key obtained from the Create Session Token API. Below is sample code on how to encrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String encrypt(byte[] publicKey, String inputData, String rsaAlgoType) throws Exception { 

    LOG.info("Start Encrypt"); 

    // Provider added for new algorithm (RSA/None/OAEPWithSHA512AndMGF1Padding) support 
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 

    X509EncodedKeySpec ks = new X509EncodedKeySpec(publicKey); 
    KeyFactory kf = KeyFactory.getInstance(ALGORITHM); 
    PublicKey key = kf.generatePublic(ks); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.ENCRYPT_MODE, key); 
    byte[] cryptogram = cipher.doFinal(inputData.getBytes()); 
    final String encValue = new String(Base64.encodeBase64(cryptogram)); 
    return encValue; 
} 
```

### RSA Decryption
Below is sample code on how to decrypt using RSA however, the Merchant may not need decryption methods for RSA since the Fiserv backend will decrypt the request payload in order to process the request. The merchant may still want to decrypt the request payload based on a variety of different factors. Below is a sample code on how to decrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String decrypt(byte[] privateKey, String inputData,String rsaAlgoType) throws Exception { 
    LOG.info("Start Decrypt"); 
    PrivateKey key = KeyFactory.getInstance(ALGORITHM).generatePrivate(new PKCS8EncodedKeySpec(privateKey)); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.DECRYPT_MODE, key); 
    byte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(inputData)); 
    LOG.info("End Decrypt"); 
    return new String(decryptedBytes, "UTF-8"); 
} 
```
</details>

<details>
<summary>5. AES Decryption</summary>
<br>
The merchant must implement the AES decryption method in order to decrypt the response payload after making a call.

### AES Specification
| Type | Value            | 
|------|------------------|
|ALGO  |AES               | 
|CIPHER| AES/GCM/NoPadding|

### AES Decryption
The AES decryption method will be used to decode the response payload using the AES key and IV once the process is complete. Below is sample code on how to decrypt using RSA:

```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;
    
    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * Decryption with secret key, IV and salt (IV value)
    */
    public String decrypt(String ciphertext) throws Exception {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(base64(ciphertext));
            byte[] iv = new byte[IV_LENGTH_BYTE];
            buffer.get(iv);
            byte[] extractedCipherText = new byte[buffer.remaining()];
            buffer.get(extractedCipherText);
            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, secretKey, initializationVector, extractedCipherText);
            return new String(decrypted, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```
</details>

## Sample JSON Response for SDK
```json
{
"componentDelta": "responseDataEncryptedUsingAESKey" 
"componentFallBack": "{string}"
}
```

### Response Data Elements Specification for SDK

|Data Element|Description|Requires Encryption| Required?| Rules|Data Type| Minimum Length| Maximum Length|#Occur|
|------------|-----------|-------------------|----------|------|---------|---------------|---------------|------|
|componentDelta|Encrypted Response Payload|Y|O||||||
|componentFallBack|This would only be populated if decryption failed on ConnectPayAPI because SDK sent details which resulted in decryption exception. This would be clear error response payload which signifies decryption error.|N|O||||||

### Decrypted Component Delta JSON format for SDK
```json
{
"transactionStatus": "{string}", 
"transactionStatusCode": "{string}", 
"referenceTransactionID": "{string}", 
"transactionStatusDescription": "{string}", 
"responseVerbiage": "{string}",
"nonce": "{string}",
"errorDetails": [
{
"errorCode": "{string}",
"errorField": "{string}",
"errorReason": "{string}"
}
],
"account": [
{
"userDetails": {
"firstName": "{string}",
"lastName": "{string}",
"email": "{string}"
},
"userAddressDetails": {
"street": "{string}",
"street2": "{string}",
"state": "{string}",
"city": "{string}",
"postalCode": "{string}"
},
"userIdentificationDetails": { 
"routingNumber": "{string}", 
"accountNumber": "{string}", 
"onlineBankTransactionId": "{string}"
},
"userPhone": [
{
"number": "{string}"
}
]
}
],
" teleCheckDetails ": { 
"transactionId": "{string}", 
"tckResponseCode": "{string}", 
"approvalCode": "{string}", 
"denialRecordNumber": "{string}", 
"displayText": "{string}", 
"sequenceId": "{string}", 
"ecaOfferCode": "{string}", 
"achTransactionStatus": "{string}", 
"amount": "{string}",
"currency": "{string}", 
"responseMessageMisc": "{string}", 
"dateTime": "{string}", 
"returnCheckFee": "{string}", 
"returnCheckNote": "{string}",
"key": "{string}",
"accessId": "{string}",
"merchantId": "{string}", 
"description": "{string}", 
"merchantReference": "{string}", 
"paymentType": "{string}",
"returnUrl": "{string}",
"cancelUrl": "{string}", 
"requestSignature": "{string}", 
"onlineBankTransactionId": "{string}" },
"partner": {
"subscriberID": "{string}" },
"customer": {
"fdCustomerID": "{string}", 
"externalID": "{string}"
},
"security": {
"tokenID": "{string}", 
"issuedOn": "{timestamp}", 
"expiresInSeconds": "{number}", 
"publicKey": "{string}", 
"alogorithm": "{string}",
"status": "{string}"
}
}
```


###  Step 1: Create Session Token
<p>
The Create Session Token API call is used to create a session token and to retrieve the RSA public key. This API is secured as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s server. Below is more information on the API specification as well as example request and response payloads. </p>

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/security/createsessiontoken&branch=develop&version=1.0.0)


Example Request Payload:

Use the payload below to create the Authorization Header.
```json
{
  "security": {
    "publicKeyRequired": true
  }
}
```

Example Response Payload:
```json
{
    "transactionStatus": "APPROVED",
    "transactionStatusCode": 0,
    "referenceTransactionID": "bedceb8b-2445-b1d5-4c1e-c09446099023",
    "transactionStatusDescription": "OK",
    "security": {
        "tokenID": "0HMxmsoYJRfAiGdxEsjcso3K8uY6",
        "issuedOn": "1583174178590",
        "expiresInSeconds": "599",
        "publicKey": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArAhyMQmqTL798rKAixN9jtnp4SFF5PVpqc/HKNprSSoaANsnpJLSTRLFMCuQIa2dcgFZM+nSPvSCGowD65/tMWBHTWfeXiSV1xWmhPdEQRocmUaRp3HoEO3RU1n5os9jQLMGEcyxopgtTvUydJSrjLWNGcC9UC50HIEBEOBqycRvqlI/oRO1oBIx8UPAe/dGKTO8Bx8f6J4Lyi5ilW0gFFYSni/Krg/fMrxu6luyGmBOr2H9zy6fv+8dLQd0LEoOAaZ/2RLfcTPnheyV7eUOvOS4DGISiQBRpXyu9Zlo1B3GbiXX8NkfCo2ByDq+6gELji7Tr+gT+zuj+5H12eQIDAQAB",
        "algorithm": "RSA/None/PKCS1Padding",
        "status": "ACTIVE"
    }
}
```

### Step 2: Create & Request Payload
At this step, all prerequisites have been complete in order to make our first call. First, the request payload must be created. The entire payload must be encrypted using different encryption methods. It must also be decrypted in order to decode the response payload into something that is readable. We will use the "Add Consumer Profile" as the example API. 

> Note: We will need to use the `tokenID` for the `Client-Token` header as well as the RSA `publicKey` in order to encrypt a portion of the payload before making the API call. Save these two pieces of information from the "Create Session Token" API used earlier in order to complete the call.


## Create Session Token
<p>
The Create Session Token API call is used to create a session token and to retrieve the public encryption key generated for this session. This information will be used to initialize the ConnectPay SDK for every use case. This API is secured as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s web server. Below are the details of the API end point.
</p>

## Connectivity
|Attribute|Value|
|---------|-----|
|Cert  API Endpoint | https://cat.api.firstdata.com/gateway/v2/connectpay/security/createsessiontoken|
|Production  API Endpoint | https://prod.api.firstdata.com/gateway/v2/connectpay/security/createsessiontoken|

## Header Description
|Headers|Description|
|---------|-----|
|Content-Type|application/json|
|Api-Key|Merchant’s ConnectPay FirstAPI key|
|Timestamp|Request initiation timestamp, expecting Epoch time. The value has to generate out of UTC timestamp and it is in milliseconds. Sample value format is 1499961987232|
|Authorization|HMAC for Authenticating Merchant with ConnectPay on FirstAPI, and Authorizing to process business functionality
Value for this header should be the word HMAC, followed by a space, followed by values for computed HMAC. Example : HMAC G9FqRSvZGMuJbjgLovkdlYz9ppBGh0++/5d/BIwoUuE= |

### Request Body
<p>
This is the only request where payload is not encrypted, since this call is requesting the Public Encryption Key to encrypt subsequent calls.
</p>
<p>
Sample request body for CreateConsumerProfile, ConsumerEnrollment, AccountValidations, GetConsumerAccountDetails, GetConsumerAccountList, ACH Transaction calls:
</p>

```json
{
    "security": {
      "publicKeyRequired": "true" 
    }
}
```
Sample request body for MicroDepositValidation, ConsumerUpdates and ACH account closure:
```json
{
    "account": [
      {
        "fdAccountID": "CP1GWQ1571349549912484x2r1yf", 
        "type": "ACH"
      }
      ], 
      "security": {
        "publicKeyRequired": "true" 
    }
}
```
|Data Element|Description|Requires Encryption|Required?|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|-------------------|---------|-----|---------|--------------|--------------|-------|
|fdAccountID|fdAccountID is required for MicroDepositValidation , ConsumerUpdates and ACH account closure calls|N|C||A,N|1|50|<=1|
|type|Defines the account type for this request.Should always be **ACH**. This element should be present if account section is present|N|C||A|3|3|1|
|publicKeyRequired|Specifies if a public key is required in response.Allowable values for this field are either **true** or **false**|N|Y||A|4|5|1|



### Response Body
<p>Create session token response would contain the response in unencrypted / clear / readable format.</p>
<p>RSA public key from the response of this call would be used to encrypt the AES key and IV for the subsequent calls.</p>
<p>Until the end of this call we would not have all the necessary pieces of information for doing a full payload encryption / decryption</p>
<p>Sample response body for CreateSessionToken call</p>

```json
{
"transactionStatus": "APPROVED",
"transactionStatusCode": 0,
"referenceTransactionID": "ee5870a4-b5a4-3cc8-89da-e67f30c6628c", "transactionStatusDescription": "OK",
"security": {
"tokenID": "0zdH0UyzmQN9m2zbYsFmm0MS4jgd", "issuedOn": "1571430030138",
"expiresInSeconds": "599",
"publicKey":
"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs+OzWu916RvgPWkqXN79onLlMlSwIp0P WylPshXhybp/127cvPNblbzq3dIOysGHZK8ZNVjYA5qETmE98wLqM/msBepdslnjj9Z6DNiDruQo4K6L6 EV7K8Nz258ZE6OgBoixy5ZQDFgIgzlpGfEmgQrfG0CiFe7oeC8BXRyWlZNJjvf0ya7Wn/UN5cM8qpf1lR0 ySJTWcxsQz1qSMRB5KEtQjz/Yyj9f9YyvvNCn/aCg45ydKcrGSCpfeLQtsCknviukcsudmBFbJtsTKUjPQ deuUCy4ToD2lKdwQmE+cZQG/FvAVM1MFvK65q6N5TaTx1a6RGfxP5WyKDcHQZDS3QIDAQAB",
"algorithm": "RSA/None/PKCS1Padding",
"status": "ACTIVE" }
}
```
<p>The Create Session Token API call is used to create a session token and to retrieve the RSA public key. This API is secured as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s server. Below is more information on the API specification as well as example request and response payloads. </p>

Try it below to also see acceptable error and acceptance codes: 
[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/security/createsessiontoken&branch=develop&version=1.0.0)



## Create Consumer Profile

<p>
The Create Consumer Profile call is mandatory for any new user enrollment using the ConnectPay SDK. This is used to create an fdCustomerId for a provided external id (and other user information) by the merchant. The returned fdCustomerId should be used right from the enrollment use case.</p>
<p>
This API is secured, as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s web server. Below are the details of the API end point.</p>

>Please Note: Merchants who will be using Fiserv’s Universal Commerce (uCom) gateway should use “Create
Customer Profile API” from their uCom implementation guide.

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/consumerprofile/add&branch=develop&version=1.0.0)

<p>
|Attribute|Value|
|---|---|
|Certification API End Point|https://cat.api.firstdata.com/gateway/v2/connectpay/consumerprofile/add|
|Production API End Point|https://prod.api.firstdata.com/gateway/v2/connectpay/consumerprofile/add|
</p>
<p>
Headers|Description|
|---------|-----|
|Content-Type|application/json|
|Api-Key|Merchant’s ConnectPay FirstAPI key|
|Timestamp|Request initiation timestamp, expecting Epoch time. The value has to generate out of UTC timestamp and it is in milliseconds. Sample value format is 1499961987232|
|Authorization|HMAC for Authenticating Merchant with ConnectPay on FirstAPI, and Authorizing to process business functionality.
Value for this header should be the word HMAC, followed by a space, followed by values for computed HMAC. Example : HMAC G9FqRSvZGMuJbjgLovkdlYz9ppBGh0++/5d/BIwoUuE= |
|Client-Token |Session Token received from CreateSessionToken call. Value for this header should be Bearer, followed by a space, followed by values for tokened. Example: Bearer b361Nhsd97hsujuiUSuiua99iq9921kkjsuuahjsa | 
</p>
<br>
<p>Request Body: (Sample request body before payload encryption) </p>

```json
{
"customer": {
"externalID": "Merchant01Consumer65746635" }
}
```
<p>
|Data Element|Description|Requires Encryption|Required?|Rules|Data Type|Minimum Length|Maximum Length| #occur|
|------------|-----------|-------------------|---------------|---------|--------------|--------------|-------|
|externalID|This is the user’s unique identifier in the merchant system.|N|R||A,N|1|50|<=1|
</p>
<p>Sample request body after payload encryption and before transmission</p>

```json
{
"componentX":
"L0WLCiqw0TT0tqaRH3Ksz4wdQFf2YAnIeiCScd+hrAWO2Hlv7lDsNnQpd+ORxkIjOHmwJuC58Q0tsc WnOI2Gh5DJ75wk5xnp/0RWQoB2+pTMGo6On+O+vFxkhVQRKlRgJu0G/RNZV4EFa1iBdDTY6UZL0I WtqDT1zwUiu+2NWAOdPDIbAIsekhJrhRAIFNsHeiYhUxBCsF+gxybJupB0XjGIWhAkPjO7AKPR1fXWU/ ZRifzsdu1/X43DSTz4d4/bYAD6iAaSBJUewSVwUG9OodeU84LYgdba4vRNa2G3BpzfomdvK6H1C8pj HjnVjUGP2F3IO6tMDnpAFZfrxvytlg==",
"componentY": "K5BTgBGzhIux2ZnodU4MWRUVhUFbU4P376TLTHZa02nU2jVb2pAWK3gMfpEHsE7WeoLlNrzAJwR 1FJ679z4Oo/yWp7k39zamQNlMHvm6EYBBbxIemexBHIIqqNRFdHhq6S3pA6L/9ItyscEl5/zZIKxcx44hv CCPZOZUhnOTSc4ehPnYJhdJQFgIDhY5UPRRZntM8hP2hOPZTVz5D4re17bSYVOEEK7bmpGIWpf9p ERUj4MlUpyRpafNd2mQsZpXPvW3XZfHDbslO7o3LourFHRSqAfBHOfx+pwH+YcMwglnay/Ay2SYWyZ hKkD+UcHSkyBdk/AMdcKt1K9uCIPm/Q==",
"componentDelta": "KKRKg/jPcb+r/3TZmhLP/KxrMEajXKvBYQd5jeGFm2OzznUvNHuyEhWyJc4RlXFRoLhwcj9eEuSOz0a bTAeU+Xw8hSMJ6kYhHokJ3ev8tgQ="
}
```
<br>
Data Element|Description|Requires Encryption|Required?|Rules|Data Type|Minimum Length|Maximum Length| #occur|
|------------|-----------|-------------------|---------------|---------|--------------|--------------|-------|
|componentX|Secret for AES encryption, encrypted using public key from create session|Y|R||A,N|32|32|<=1|
|componentY|IV for Data Encryption and Decryption|Y|R||A,N|16|16|<=1|
|componentDelta|Encrypted Payload|Y|R||A,N|1||<=1|
<br>
<p>Response Body:</p>
<br>
<p>ConnectPay profile add response may contain either **componentDelta** or **componentFallBack** elements</p>
<tab>  • componentDelta: is encrypted ConnectPayAPI response.</p>
<tab>  • componentFallBack : is unencrypted response and is onlyx triggered in cases of </p>
<p>         o Sessiontimeout(responsefromApigee) </p>
<p>         o Encryption/decryptionlogicfailsonConnectPayAPI(inthiscaseencryption/decryption failed so not able to give back encrypted response).</p>

<p>In either case, the decrypted/unencrypted version of this payload has three high level transactionStatus , namely, APPROVED/DECLINED/ERROR.</p>

**APPROVED** as the name suggests represents a successful outcome.
<br>

**DECLINED** status signifies that ConnectPayAPI rejected the request either due to format validation or business validation.
<br>

**ERROR** status signifies a system error or equivalent.
<br>

<p>Sample response body after it is received with payload encryption</p>

```json
{
"componentDelta":
"cRD5xVaJab13iRQ7l6No6ot9YPTFT3bi/qapHYGgsNmxQ8nT2mtIz7uLLHz5kdp5JEmDjiP1dXMNPg8j P5rIZQf/5dtMfFLq7YL7FQY/boTsd7BoJg7reDeeAk6l9+76gaSAZMIRJGYS4fhy1bgClx2jIeWo4fLlfildeH nghCU1ElR8XhFi3oyd8hU+YEpDENP5IJJMVxjnYChuFX8paVy/SAYFMESBXSTIgPi6Y/kJc/bswlxaa9Yei 4GnD+Ny1laVs4HqJp32JJ+NHJIYdZr5117AY0JJxJ9oudnkK6J8oPnnXhLCBGxNCRDJG3AVLRxDnQc ds/cSiwAVREHr4nn848IEsUb27wJR7SiDxVaELxme9CNZ1dB0tPYQ1wux3ymWtnUgLfVRFsHH3Eeuc bHv8uIc8dxcwxZReROzVS8="
}
```
<br>
|Data Element|Description|Requires Encryption|Required|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|-------------------|--------|-----|---------|--------------|--------------|-------|
|componentDelta|Encrypted Payload|Y|R||A,N|1||<=1|

<p>JSON sample data for APPROVED response body after payload decryption</p>

```json
{
"transactionStatus": "APPROVED",
"transactionStatusCode": 0,
"referenceTransactionID": "5cdd1d99-5367-ed98-56fd-3f52ab008ac8", "transactionStatusDescription": "Created",
"customer": {
"fdCustomerID": "CP1GWQ15714280477520000262L7Wymj",
"externalID": "Merchant01Consumer65746635" }
}
```

<p>JSON sample data for APPROVED response body after payload decryption(If externalID already enrolled in ConnectPay)</p>

```json
{
"transactionStatus": "APPROVED",
"transactionStatusCode": 10,
"referenceTransactionID": "5cdd1d99-5367-ed98-56fd-3f52ab008ac8", "transactionStatusDescription": "Previously Created",
"customer": {
"fdCustomerID": "CP1GWQ15714280477520000262L7Wymj",
"externalID": "Merchant01Consumer65746635" }
}
```

<p>JSON datatype definition for APPROVED response body after payload decryption</p>
<br>
|Data Element|Description|Required|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|--------|-----|---------|--------------|--------------|-------|
|transactionStatus|Overall status of the call|R|Allowable Values : APPROVED, DECLINED, ERROR|A|5|11|=1|
|transactionStatusCode|Unique code signifying detailed transaction status|R||N|1|3|=1|
|referenceTransactionID|Unique ID for each Transaction which could be used to trace a transaction. **It is highly recommended that merchants should store the ID on their side. This can be used for researching the transactions in case issue arises**|O||A,N,S0,S1,S2|1|100|<=1|
|transactionStatusDescription|Short description of statusCode|O||A,S0,S1,S2|1|30|<=1|
|fdCustomerID|Unique consumer identifier in Fiserv Telecheck|O||A,N|1|50|<=1|
|externalID|Unique consumer identified|O||A,N|1|50|<=1|

<p>JSON sample data for DECLINED response body after payload decryption</p>

```json
{
"transactionStatus": "DECLINED",
"transactionStatusCode": 409,
"referenceTransactionID": "bbb59fe8-492f-9c53-3a30-73637cb2d7d9", 
"transactionStatusDescription": "Conflict",
"responseVerbiage": "Conflict",
"errorDetails": [
  {
"errorCode": 4910,
"errorField": "externalID",
"errorReason": "ExternalID already used by another Customer"
  }
 ]
}
```
<p>JSON datatype definition for DECLINED response body after payload decryption</p>

```json
{
 "transactionStatus": "DECLINED",
 "transactionStatusCode": 409,
 "referenceTransactionID": "bbb59fe8-492f-9c53-3a30-73637cb2d7d9", "transactionStatusDescription": "Conflict",
 "responseVerbiage": "Conflict",
 "errorDetails": [
    {
    "errorCode": 4910,
    "errorField": "externalID",
    "errorReason": "ExternalID already used by another Customer"
    } 
  ]
}
```
|Data Element|Description|Required|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|--------|-----|---------|--------------|--------------|-------|
|transactionStatus|Overall status of the call|R|Allowable Values : APPROVED, DECLINED, ERROR|A|5|11|=1|
|transactionStatusCode|Unique code signifying detailed transaction status|R||N|1|3|=1|
|referenceTransactionID|Unique ID for each Transaction which could be used to trace a transaction. **It is highly recommended that merchants should store the ID on their side. This can be used for researching the transactions in case issue arises**|O||A,N,S0,S1,S2|1|100|<=1|
|transactionStatusDescription|Short description of statusCode|O||A,S0,S1,S2|1|30|<=1|
|responseVerbiage|Detailed description of transactionStatus|O||A,N,S0,S1,S2|1|1000|<=1|
|errorCode|Code signifying what kind of error occurred|O||N|1|4|<=1|
|errorField|Signifies which input field that caused the error|O||A|1|30|<=1|
|errorReason|Short description of the error|O||A,S1|1|100|<=1|
<p>JSON sample data for ERROR response body after payload decryption</p>

```json
{
 "transactionStatus": "ERROR",
 "transactionStatusCode": 100,
 "referenceTransactionID": "906c517e-5570-4286-86c2-33dc3e0d18cc", 
 "transactionStatusDescription": "Input is invalid",
 "errorDetails": [
   {
    "errorCode": 1035,
    "errorField": "InitializationVector", 
    "errorReason": "Required field is missing"
   } 
 ]
}    
```
<p>JSON datatype definition for ERROR response body after payload decryption</p>
|Data Element|Description|Required|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|--------|-----|---------|--------------|--------------|-------|
|transactionStatus|Overall status of the call|R|Allowable Values : APPROVED, DECLINED, ERROR|A|5|11|=1|
|transactionStatusCode|Unique code signifying detailed transaction status|R||N|1|3|=1|
|referenceTransactionID|Unique ID for each Transaction which could be used to trace a transaction. **It is highly recommended that merchants should store the ID on their side. This can be used for researching the transactions in case issue arises**|O||A,N,S0,S1,S2|1|100|<=1|
|transactionStatusDescription|Short description of statusCode|O||A,S0,S1,S2|1|30|<=1|
|responseVerbiage|Detailed description of transactionStatus|O||A,N,S0,S1,S2|1|1000|<=1|
|errorCode|Code signifying what kind of error occurred|O||N|1|4|<=1|
|errorField|Signifies which input field that caused the error|O||A|1|30|<=1|
|errorReason|Short description of the error|O||A,S1|1|100|<=1|

<P>JSON sample data without payload encryption (componentFallBack)</p>

```json
{
**"componentFallBack"**: "{\r\n \"transactionStatus\" : \"DECLINED\",\r\n \"transactionStatusCode\ " : 420,\r\n \"referenceTransactionID\" : \"APIGEE-a-90f-4946-ff14-
36aa4b9a6325\",\r\n \"transactionStatusDescription\" : \"Unauthorized\",\r\n \"responseVerbia ge\" : \"Unauthorized\",\r\n \"errorDetails\" : [ {\r\n \"errorCode\" : 4250,\r\n \"errorField\" :
\"Client-Token\",\r\n \"errorReason\" : \"Session time out\"\r\n } ]\r\n}" }
```
<p>Datatype definition without payload encryption (componentFallBack)</p>
<br>
|Data Element|Description|Required|Rules|Data Type|Minimum Length|Maximum Length|# Occur|
|------------|-----------|--------|-----|---------|--------------|--------------|-------|
|transactionStatus|Overall status of the call|R|Allowable Values : APPROVED, DECLINED, ERROR|A|5|11|=1|
|transactionStatusCode|Unique code signifying detailed transaction status|R||N|1|3|=1|
|referenceTransactionID|Unique ID for each Transaction which could be used to trace a transaction. **It is highly recommended that merchants should store the ID on their side. This can be used for researching the transactions in case issue arises**|O||A,N,S0,S1,S2|1|100|<=1|
|transactionStatusDescription|Short description of statusCode|O||A,S0,S1,S2|1|30|<=1|
|responseVerbiage|Detailed description of transactionStatus|O||A,N,S0,S1,S2|1|1000|<=1|
|errorCode|Code signifying what kind of error occurred|O||N|1|4|<=1|
|errorField|Signifies which input field that caused the error|O||A|1|30|<=1|
|errorReason|Short description of the error|O||A,S1|1|100|<=1|

## Get Connectpay Profile

<p>The Get CP Profile method is used to get consumer profile `fdCustomerID` and `externalID` using `fdCustomerID` or `externalID`</p>
<br>
<p>Example :</p>
<br>
Merchant X for some unforseen event loses the `fdCustomerId` for the corresponding `externalID` in their record.
<br>
In that scenario merchant can call this service to retrieve the `fdCustomerId` using the `externalID`.
<br>
Merchant does not send another create profile because its sure profile exists, just the data need to be retrieved.
<br>
This API is secured, as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s web server. Below are the details of the API end point.
<br>

>Merchants who will be using Fiserv’s Universal Commerce (uCom) gateway should use “Create Customer Profile API” from their uCom implementation guide 
[uCom Implementation Guide](https://developer.fiserv.com/product/ConnectedCommerce/api/?type=post&path=/v1/customers&branch=main&version=1.0.0)

<p>
|Attribute|Value|
|---------|-----|
|Certification End Point|https://cat.api.firstdata.com/gateway/v2/connectpay/consumerprofile/get|
|Production API End Point|https://prod.api.firstdata.com/gateway/v2/connectpay/consumerprofile/get|
|HTTP Method|POST|
</p>
<p>
|Headers|Description|
|-------|-----------|
|Content-Type| application/json|
|Api-Key|Merchant’s ConnectPay FirstAPI key|
|Timestamp|Request initiation timestamp, expecting Epoch time. The value has to generate out of UTC timestamp and it is in milliseconds. Sample value format is 1499961987232|
|Authorization|HMAC for Authenticating Merchant with ConnectPay on FirstAPI, and Authorizing to process business functionality. Value for this header should be the word HMAC, followed by a space, followed by values for computed HMAC. Example : HMAC G9FqRSvZGMuJbjgLovkdlYz9ppBGh0++/5d/BIwoUuE=|
|Client-Token|Session Token received from CreateSessionToken call. Value for this header should be Bearer, followed by a space, followed by values for tokened. Example: Bearer b361Nhsd97hsujuiUSuiua99iq9921kkjsuuahjsa|
</p>
Request Body:
<br>
Sample request body before payload encryption:

```json
{
    "customer": {
        "fdCustomerID": "CP87rx15814147322210000442tJpajq",
        "externalID": " Merchant01Consumer65746635" 
    }
}
```


[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/consumerprofile/enrollment&branch=develop&version=1.0.0)
